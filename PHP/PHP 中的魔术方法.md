## 魔术函数
### `__autoload()`
这个函数会在试图使用尚*未被定义*的类时自动调用。通过调用这个函数，脚本引擎在 PHP 出错失败之前有了最后一个机会加载所需的类。

- `__autoload($className)`

> 注意：这是一个函数，而不是一个方法，所以不是在类中定义，而是在当前执行脚本文件中定义。

> 注意：这里的*未被定义*是指在当前执行环境上下文中找不到相应的类的定义。如果在其他的一个文件中定义了类，但是在当前的执行环境中没有引入这个类的定义文件，那么这个类在当前执行环境中也是*未被定义*的。

> 注意：在`__autoload()`函数中抛出的异常不能被`catch`语句块捕获并导致致命错误。


## 魔术方法
PHP 中，类中可以定义很多魔术方法，以处理各种情况下的自动调用。

需要注意的是，这些魔术方法的访问权限都**必须是公共的**。
### `__get()`、`__set()`
这两个方法是为在类和他们的父类中**没有声明**的属性而设计的：

- `__get($property)` 当调用一个*未定义*的属性时，自动调用这个方法；
- `__set($property)` 当给一个*未定义*的属性赋值时，自动调用这个方法。

> 注意：这里的**没有声明**包括类中定义的访问控制为`protected`和`private`的属性(即没有权限访问的属性)，而非仅仅是一般意义上的“未声明”或“未定义”。

### `__isset()`、`__unset（）`

- `__isset($property)` 当在一个*未定义*的属性上调用`isset()`方法时自动调用这个方法；
- `__unset($property)` 当在一个*未定义*的属性上调用`unset()`方法时自动调用这个方法。

> 注意：这里的*未定义*和前面的`__get()`、`__set()`方法的意义相同，包含无访问权限的属性。

### `__call()`
当调用一个*未定义*的方法时自动调用这个方法。

- `__call($method, $arg_array)`

这个方法的参数分别表示：

* `$method`  真正调用的方法的名称；
* `$arg_array`  调用`$method`方法时传入的参数，是一个数组，按照调用时参数的顺序排列。

> 注意：这里的*未定义*包含没有访问权限的方法。

### `__construct()`、`__destruct（）`
这两个方法会在对象实例化和销毁的时候调用，以便初始化和清理一些信息。

- `__construct()` 构造方法，当一个对象被创建的时候自动调用这个方法。一般会在这个方法中做一些对象属性的初始化工作。
- `__destruct()` 析构方法，当一个对象被销毁(从内存中清除)前，自动调用这个方法。默认情况下，PHP 仅仅释放对象属性所占用的内存并销毁对象的相关资源。而通过这个方法，我们也能自动控制一些资源的释放或其他的处理工作。

> 注意：当 PHP 决定你的脚本不再与对象相关时，析构方法会被调用；在一个函数的命名空间内，析构方法会在函数`return`的时候调用；对于全局变量，析构方法会在脚本结束时调用。

> 注意：如果你想明确的销毁一个对象，可以给指向这个对象的变量分配任何其他值，通常将变量赋值为`Null`或者直接调用`unset()`方法。

### `__clone()`
PHP 5 中的对象赋值是使用的引用赋值方式，如果想复制一个对象，则需要使用`clone` 语法结构(`$obj2 = clone $obj2`)。

如果在对象复制的过程中，需要执行一个初始化操作，则可以在类的`__clone()`方法中实现。

### `__toString()`
在讲一个对象转化成字符串的时候，会自动调用`__toString()`方法。比如，一般情况下，类中没有实现这个方法，我们就无法通过`echo`语句打印对象，会出现致命错误：Catchable fatal error: Object off class test could not be converted to string in ...

通过实现`__toString()`方法，我们能将对象转换成特定的字符串。

> 注意：在 PHP 5.2.0 之前，这个方法只有接合使用`echo()`或`print()`时才能生效；在 PHP 5.2.0 之后，则可以在任何字符串环境中生效(例如通过`printf()`方法，使用`%s`修饰符)，蛋不能用于非字符串环境(如`printf()`方法，使用`%d`修饰符)。
> 从 PHP 5.2.0开始，如果将一个未定义`__toString()`方法对象转化为字符串，会报出一个`E_RECOVERABLE_ERROR`错误。

### `__sleep()`、`__wakeup()`
这两个方法一般用在将对象序列化或反序列化恢复对象的时候被调用。

- `__sleep()` 序列化对象的时候自动调用。一般需要在这个方法中清除对象，并应该返回一个包含有该对象中应该被序列化的所有变量名的数组。使用这个方法主要是为了关闭对象可能具有的数据库连接、提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而不需要完全存储下来的时候，此方法也很有用。

- `__wakeup()` 反序列化字符串恢复出对象的时候自动调用，可以根据字符串中保存的对象的信息来完成对象的恢复，比如完成数据库的链接初始化等。

在对对象调用`serialize()`函数的时候，会检查类中是否有名称为`__sleep()`的魔术方法。如果有，则会先调用这个方法。相对应的，如果调用`unserialize()`函数从序列化字符串中恢复一个对象的时候，会先检查这类对象中是否有`__wakeup()`方法，有的话就会先调用这个方法。

### `__set_state()`
当调用`var_export()`函数时，这个静态方法会被自动调用(自 PHP 5.1.0 有效)。

- `__set_state(array $a)`

这个方法的唯一参数是一个索引数组，其中包含按键值对格式排列的类的属性和对应的值。

### `__invoke()`
当尝试以调用函数的方式调用一个对象时，`__invoke()`方法会被自动调用(PHP 5.3.0 以上有效)。

### `__callStatic()`
这个方法的工作方式类似于`__call()`魔术方法，但是这个方法是为了处理静态方法调用的。(PHP 5.3.0 版本以上有效。)

> 注意：`__callStatic()`方法必须被声明为静态的。


