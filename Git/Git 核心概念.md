### 总结

1.	Git 保存文件的完整内容，不保存差量变化。

2.	Git 以储键值对（key-value）的方式保存文件。

3.	每一个文件，相同文件的不同版本，都有一个唯一的 40 位的 SHA-1 校验和与之对应。

4.	SHA-1 校验和是文件的指针，Git 依靠它来区分文件。

5.	每一个文件都会在 Git 的版本库里生成 blob 对象来保存。

6.	对于没有变化的文件，Git 只会保留上一个版本的指针。

7.	Git 实际上是通过维持复杂的文件树来实现版本控制的。

8.	使用 Git 的工作流程基本就是就是文件在三个工作区域之间的流动。

9.	应该大量使用分支进行团队协作。

10. 分支只是对提交对象的一个引用。


### Git 基础原理

Git 每一次提交都是对项目文件的一个完整拷贝，因此你可以完全恢复到以前的任一个提交而不会发生任何区别。这里有一个问题：如果我的项目大小是 10M，那 Git 占用的空间是不是随着提交次数的增加线性增加呢？我提交（commit）了10次，占用空间是不是 100M 呢？很显然不是，Git 是很智能的，如果文件没有变化，它只会保存一个指向上一个版本的文件的指针，即：对于一个特定版本的文件，Git 只会保存一个副本，但可以有多个指向该文件的指针。未变化的文件只保存上一个版本的指针。

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475826508370.png" width="275"/>

### Git 对象

#### SHA-1 校验和

Git 是一套内容寻址文件系统。意思就是 Git 从核心上来看不过是简单地存储键值对（key-value）， value 是文件的内容，而 key 是文件内容与文件头信息的 40 个字符长度的 SHA-1 校验和，例如：5453545dccd33565a585ffe5f53fda3e067b84d8。Git 使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新 checkout 某个 commit 时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA-1 校验和，这种现象叫做“雪崩效应”（Avalanche effect）。

SHA-1 校验和因此就是上文提到的文件的**指针**。和 C 语言中的指针概念有点类似。不过 Git 指针指向的文件内容发生变化时，指针也会发生变化。所以，Git 中每一个版本的文件，都有一个唯一的指针指向它。

#### 文件(blob)对象，树(tree)对象，提交(commit)对象

blob 对象保存的仅仅是文件的内容，tree 对象更像是操作系统中的文件夹，它可以保存 blob 对象和 tree 对象。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 对象或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息等：

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475826793234.png" width="275"/>

当你对文件进行修改并提交时，变化的文件会生成一个新的 blob 对象，记录文件的完整内容（是全部内容，不是变化内容），然后针对该文件有一个唯一的 SHA-1 校验和，修改此次提交该文件的指针 为该 SHA-1 校验和，而对于没有变化的文件，简单拷贝上一次版本的指针即 SHA-1 校验和，而不会生成一个全新的 blob 对象，这也解释了 10M 大小的项目进行 10 次提交总大小远远小于 100M 的原因。

但是 tree 对象中的信息没有作者、时间、保存这些快照的原因。而 commit 对象就是问了解决这些问题诞生的， commit 对象的格式很简单：指明了该时间点项目快照的顶层 tree 对象、作者/提交者信息（从 Git 设置的 user.name 和 user.email 中获得)以及当前时间戳、一个空行，上一次的提交对象的 I D以及提交注释信息。

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475826926199.png" width="275"/>

上图的 Test.txt 是第一次提交之前生成的，第一次它的初始 SHA-1 校验和以 3c4e9c开头。随后对它进行了修改，所以第二次提交时生成了一个全新 blob 对象，校验和以 1f7a7a 开头。而第三次提交时 Test.txt 并没有变化，所以只是保存最近版本的 SHA-1 校验和而不生成全新的 blob 对象。在项目开发过程中新增加的文件在提交后都会生成一个全新的 blob 对象来保存它。注意除了第一次每个提交对象都有一个指向上一次提交对象的指针。

因此简单来说，blob 对象保存文件的内容；tree 对象类似文件夹，保存 blob 对象和其它 tree 对象；commit 对象保存 tree 对象，提交信息，作者，邮箱以及上一次的提交对象的 ID（第一次提交没有）。而 Git 就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。

### Git 引用

虽然我们可以通过提交的 40 位的 SHA-1 校验和 ID 来引用某个历史版本，但是太难记，所以引用就是 SHA-1 校验和的别名，存储在`.git/refs`文件夹中。

在 Git 中每个分支的名称就是一个引用别名，`branch-name`分支对应的存储文件是`.git/refs/heads/branch-name`，这是一个文本文件，里面存储的内容就是项目 branch-name 分支的最后一次提交记录的 SHA-1 码。比如，我们查看 master 分支对应的文件中的内容：

```
$ cat .git/refs/heads/master
4f3e6a6f8c62bde818b4b3d12c8cf3af45d6dc00
```

因此 master 只是一个 40 位 SHA-1 校验和的别名罢了。

另外，我们一般会用到 HEAD 来引用当前分支的最后一次提交，那么 HEAD 对应的文件中的内容是什么呢？HEAD 对应的文件是`.git/HEAD`，查看其中的内容：

```
$ cat .git/HEAD
ref: refs/heads/master
```

可以看到，HEAD 文件其实并不包含 SHA-1 值，而是一个指向当前分支的引用，内容会随着切换分支而变化，内容格式像这样：`ref: refs/heads/<branch-name>`。当你执行`git commit`命令时，它就创建了一个 commit 对象，并把这个 commit 对象的父级设置为 HEAD 指向的引用的 SHA-1 值。

Git 的 tag，标签从某种意义上像是一个引用：它指向一个 commit 对象而不是一个 tree，包含一个标签，一组数据，一个消息和一个 commit 对象的指针。但是区别就是：引用会随着项目进行它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 commit ，仅仅是提供一个更加友好的名字。

### 分支

在 Git 中创建分支非常快。在上文中已经说到，Git 保存文件的最基本的对象是 blob 对象，Git 本质上只是一棵巨大的文件树，树的每一个节点就是 blob 对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的 40 位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。

Git 切换分支也很快：

1.	修改`.git`文件下的 HEAD 文件为`ref: refs/heads/<分支名称>`。

2.	按照分支指向的提交记录将工作区的文件恢复至一模一样。

3.	结束。

#### 分支合并

如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。比如：

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475826304639.png" width="275"/>

> 注意箭头方向，因为每一次提交都有一个指向上一次提交的指针，所以箭头方向向左，更为合理。

当在 master 分支合并 dev 分支时，因为他们在一条线上，这种单线的历史分支不存在任何需要解决的分歧，所以只需要 master 分支指向 dev 分支即可，所以非常快。

当分支出现分叉时，就有可能出现冲突，而这时 Git 就会要求你去解决冲突，比如像下面的历史：

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475828584160.png" width="275"/>

因为 master 分支和 dev 分支不在一条线上，即 v7 不是 v5 的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（ v7 和 v5 ）以及它们的共同祖先（ v3 ）进行一次简单的三方合并计算。合并之后会生成一个和并提交v8 ：

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475828604511.png" width="275"/>

注意：合并提交有两个祖先（ v7 和 v5 ）。

#### 分支的变基 rebase

把一个分支中的修改整合到另一个分支的办法有两种：`merge`和`rebase`。首先 merge 和 rebase 最终的结果是一样的，但 rebase 能产生一个更为整洁的提交历史。仍然以上图为例，如果简单的 merge，会生成一个提交对象 v8，现在我们尝试使用变基合并分支，切换到 dev ：

```
$ git checkout dev
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
```

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475828680879.png" width="275"/>

进行 rebase 合并的时候，首先会回到两个分支最近的共同祖先 v3，根据当前分支（也就是要进行变基的分支 dev）后续的历次提交对象（包括 v4 ， v5），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（v7）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（v7'），从而改写 dev 的提交历史，使它成为 master 分支的直接下游，如下图：

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475828808145.png" width="275"/>

然后就可以回到 master 分支进行快速合并 Fast-forward了，因为 master 分支和 dev 分支在一条线上：

```
$ git checkout master
$ git merge dev
```

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1475828887076.png" width="275"/>

现在的 v7' 对应的快照，其实和普通的三方合并，即上个例子中的 v8 对应的快照内容一模一样。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。


### 转摘
[Git的核心概念](https://lufficc.com/blog/the-core-conception-of-git)

